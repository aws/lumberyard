/*
* All or portions of this file Copyright (c) Amazon.com, Inc. or its affiliates or
* its licensors.
*
* For complete copyright and license terms please see the LICENSE at the root of this
* distribution (the "License"). All use of this software is governed by the License,
* or, if provided, by the license below or the license accompanying this file. Do not
* remove or modify any license notices. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
*
*/
#include "CryLegacy_precompiled.h"
#include "UiFlow.h"
#include <FlowSystem/Nodes/FlowBaseNode.h>
#include <LyShine/ILyShine.h>
#include <LyShine/ISprite.h>
#include <LyShine/Bus/UiImageBus.h>
#include <LyShine/Bus/UiCanvasBus.h>

// Note: CFlowUiGetImageNode and CFlowUiSetImageNode are now obsolete and have been replaced with nodes
// generated by the UiFlow macros. These obsolete nodes are not being deleted because their names differ
// from the newly generated nodes.

namespace
{
    const string g_setImageNodePath = "UI:Image:SetImageSource";
    const string g_getImageNodePath = "UI:Image:GetImageSource";
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//! Flow Graph node for getting the source image of a given element
class CFlowUiGetImageNode
    : public CFlowBaseNode < eNCT_Instanced >
{
public:
    CFlowUiGetImageNode(SActivationInfo* activationInfo)
        : CFlowBaseNode()
    {
    }

    ~CFlowUiGetImageNode() override
    {
    }

    //-- IFlowNode --

    IFlowNodePtr Clone(SActivationInfo* activationInfo) override
    {
        return new CFlowUiGetImageNode(activationInfo);
    }

    void GetConfiguration(SFlowNodeConfig& config) override
    {
        static const SInputPortConfig inputs[] =
        {
            InputPortConfig_Void("Activate", _HELP("Trigger to update the output")),
            InputPortConfig<int>("CanvasID", 0, _HELP("The unique ID of the element's canvas")),
            InputPortConfig<int>("ElementID", 0, _HELP("The unique ID of the image element")),
            { 0 }
        };

        static const SOutputPortConfig outputs[] =
        {
            OutputPortConfig<string>("Value", _HELP("The source location of the image in element [ElementID]")),
            { 0 }
        };

        config.pInputPorts = inputs;
        config.pOutputPorts = outputs;
        config.sDescription = _HELP("Get the source location of the image to be displayed by the element");
        config.SetCategory(EFLN_OBSOLETE);
    }

    void ProcessEvent(EFlowEvent event, SActivationInfo* activationInfo) override
    {
        m_actInfo = *activationInfo;
        if (eFE_Activate == event && IsPortActive(activationInfo, InputPortActivate) && gEnv->pLyShine)
        {
            // Get the canvas
            int canvasID = GetPortInt(activationInfo, InputPortCanvasId);
            AZ::EntityId canvasEntityId = gEnv->pLyShine->FindCanvasById(canvasID);
            if (!canvasEntityId.IsValid())
            {
                CryWarning(VALIDATOR_MODULE_SYSTEM, VALIDATOR_WARNING, "FlowGraph: %s Node: couldn't find UI canvas with ID: %d\n", g_getImageNodePath.c_str(), canvasID);
                return;
            }

            // Get the element
            int elementID = GetPortInt(activationInfo, InputPortElementId);
            AZ::Entity* element = nullptr;
            EBUS_EVENT_ID_RESULT(element, canvasEntityId, UiCanvasBus, FindElementById, elementID);

            if (!element)
            {
                CryWarning(VALIDATOR_MODULE_SYSTEM, VALIDATOR_WARNING, "FlowGraph: %s Node: couldn't find UI element with ID: %d\n", g_getImageNodePath.c_str(), elementID);
                return;
            }

            // Check for image component
            if (UiImageBus::FindFirstHandler(element->GetId()))
            {
                ISprite* imgSprite;
                EBUS_EVENT_ID_RESULT(imgSprite, element->GetId(), UiImageBus, GetSprite);
                ActivateOutput(&m_actInfo, OutputPortValue, imgSprite->GetTexturePathname());
            }
            else
            {
                CryWarning(VALIDATOR_MODULE_SYSTEM, VALIDATOR_WARNING, "FlowGraph: %s Node: couldn't find an image component on UI element with ID: %d\n", g_getImageNodePath.c_str(), elementID);
                return;
            }
        }
    }

    void GetMemoryUsage(ICrySizer* sizer) const override
    {
        sizer->Add(*this);
    }

    //-- ~IFlowNode --

protected:

    enum InputPorts
    {
        InputPortActivate = 0,
        InputPortCanvasId,
        InputPortElementId,
    };

    enum OutputPorts
    {
        OutputPortValue = 0
    };

    SActivationInfo m_actInfo;
};

////////////////////////////////////////////////////////////////////////////////////////////////////
//! Flow Graph node for setting the source image of a given element
class CFlowUiSetImageNode
    : public CFlowBaseNode < eNCT_Instanced >
{
public:
    CFlowUiSetImageNode(SActivationInfo* activationInfo)
        : CFlowBaseNode()
    {
    }

    ~CFlowUiSetImageNode() override
    {
    }

    //-- IFlowNode --

    IFlowNodePtr Clone(SActivationInfo* activationInfo) override
    {
        return new CFlowUiSetImageNode(activationInfo);
    }

    void GetConfiguration(SFlowNodeConfig& config) override
    {
        static const SInputPortConfig inputs[] =
        {
            InputPortConfig_Void("Activate", _HELP("Trigger to update the output")),
            InputPortConfig<int>("CanvasID", 0, _HELP("The unique ID of the element's canvas")),
            InputPortConfig<int>("ElementID", 0, _HELP("The unique ID of the text element")),
            InputPortConfig<string>("ImagePath", _HELP("The source path of the image to display")),
            { 0 }
        };

        static const SOutputPortConfig outputs[] =
        {
            OutputPortConfig_Void("Out", _HELP("Fired after the node is finished")),

            { 0 }
        };

        config.pInputPorts = inputs;
        config.pOutputPorts = outputs;
        config.sDescription = _HELP("Set the source location of the image to be displayed by the element");
        config.SetCategory(EFLN_OBSOLETE);
    }

    void ProcessEvent(EFlowEvent event, SActivationInfo* activationInfo) override
    {
        if (eFE_Activate == event && IsPortActive(activationInfo, InputPortActivate) && gEnv->pLyShine)
        {
            // Get the canvas
            int canvasID = GetPortInt(activationInfo, InputPortCanvasId);
            AZ::EntityId canvasEntityId = gEnv->pLyShine->FindCanvasById(canvasID);
            if (!canvasEntityId.IsValid())
            {
                CryWarning(VALIDATOR_MODULE_SYSTEM, VALIDATOR_WARNING, "FlowGraph: %s Node: couldn't find UI canvas with ID: %d\n", g_setImageNodePath.c_str(), canvasID);
                return;
            }

            // Get the element
            int elementID = GetPortInt(activationInfo, InputPortElementId);
            AZ::Entity* element = nullptr;
            EBUS_EVENT_ID_RESULT(element, canvasEntityId, UiCanvasBus, FindElementById, elementID);

            if (!element)
            {
                CryWarning(VALIDATOR_MODULE_SYSTEM, VALIDATOR_WARNING, "FlowGraph: %s Node: couldn't find UI element with ID: %d\n", g_setImageNodePath.c_str(), elementID);
                return;
            }

            // set the image source
            string imgSrc = GetPortString(activationInfo, InputPortImageLocation);
            ISprite* sprite = gEnv->pLyShine->LoadSprite(imgSrc);
            EBUS_EVENT_ID(element->GetId(), UiImageBus, SetSprite, sprite);
            if (!sprite)
            {
                CryWarning(VALIDATOR_MODULE_SYSTEM, VALIDATOR_WARNING, "FlowGraph: %s Node: couldn't find UI Image with source: %s\n", g_setImageNodePath.c_str(), imgSrc.c_str());
                return;
            }
            sprite->Release();

            ActivateOutput(activationInfo, OutputPortOut, 0);
        }
    }

    void GetMemoryUsage(ICrySizer* sizer) const override
    {
        sizer->Add(*this);
    }

    //-- ~IFlowNode --

protected:

    enum InputPorts
    {
        InputPortActivate = 0,
        InputPortCanvasId,
        InputPortElementId,
        InputPortImageLocation,
    };

    enum OutputPorts
    {
        OutputPortOut = 0
    };
};

REGISTER_FLOW_NODE(g_setImageNodePath, CFlowUiSetImageNode);
REGISTER_FLOW_NODE(g_getImageNodePath, CFlowUiGetImageNode);


////////////////////////////////////////////////////////////////////////////////////////////////////
// Get/Set flow nodes
////////////////////////////////////////////////////////////////////////////////////////////////////

UI_FLOW_NODE__GET_AND_SET_ENUM_AS_INT(Image, ImageType, UiImageInterface::ImageType,
    "Get the type of the Image. Affects how the texture/sprite is mapped to the image rectangle.",
    "Set the type of the Image. Affects how the texture/sprite is mapped to the image rectangle.",
    "ImageType", "Stretched=0, Sliced=1, Fixed=2, Tiled=3, StretchedToFit=4, StretchedToFill=5");

UI_FLOW_NODE__GET_AND_SET_COLOR_AS_VEC3_AND_FLOAT(Image, Color,
    "Get the color tint for the image",
    "Set the color tint for the image",
    "Color", "The R G B value (0 - 255) of element [ElementID]",
    "Alpha", "The alpha value (0 - 255) of element [ElementID]");

UI_FLOW_NODE__GET_AND_SET_IMAGE_PATH_AS_SPRITE(Image, Sprite,
    "Get the source location of the image to be displayed by the element",
    "Set the source location of the image to be displayed by the element",
    "SpritePath", "The source location of the image in element [ElementID]");
